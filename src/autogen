#!/usr/bin/env python3

data = (
  (511, # same CSIDH-512 prime but only 2^220 keys
   (3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,587),
   (2,3,4,4,5,5,5,5,5,7,7,8,7,6,1),
   (6,9,11,11,12,12,12,12,12,12,12,12,8,6,1),
  ),
  (512,
   (3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,587),
   (2,3,4,4,5,5,6,7,7,8,8,6,8,1),
   (10,14,16,17,17,17,18,18,18,18,18,13,13,1),
  ),
  (1024,
   (3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,983),
   (2,3,5,4,6,6,6,6,6,7,7,7,6,7,7,5,6,5,10,3,10,5,1),
   (2,4,5,5,6,6,6,6,6,6,6,6,6,6,6,5,5,3,6,2,6,2,0)
  ),
  (2048,
   (3,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,3413),
   (9,10,8,8,7,10,12,11,10,15,10,9,8,6,10,13,10,9,12,13,10,10,10,1),
   (1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,0,2,0)
  )
)

import os
import math
import re
import sys

import chain
import costs
import distmults
import sim

sys.setrecursionlimit(10000)

def maybeupdate(fn):
  if os.access(fn,os.F_OK):
    with open(fn) as f:
      x = f.read()
    with open(fn+'.tmp') as f:
      y = f.read()
    if x == y:
      os.unlink(fn+'.tmp')
      return
  os.rename(fn+'.tmp',fn)

def batchkeys(x,y):
  poly = [1]
  for i in range(x):
    newpoly = poly+[0]
    for j in range(len(poly)):
      newpoly[j+1] += poly[j]
    poly = newpoly
  for i in range(y):
    newpoly = poly+[0]
    for j in range(len(poly)):
      newpoly[j+1] += 2*poly[j]
    poly = newpoly
  return poly[x]

def dac_search(target,r0,r1,r2,chain,chainlen,best,bestlen):
  if chainlen >= bestlen: return best,bestlen
  if r2 > target: return best,bestlen
  if r2<<(bestlen-1-chainlen) < target: return best,bestlen
  if r2 == target: return chain,chainlen
  chain *= 2
  chainlen += 1
  best,bestlen = dac_search(target,r0,r2,r0+r2,chain+1,chainlen,best,bestlen)
  best,bestlen = dac_search(target,r1,r2,r1+r2,chain,chainlen,best,bestlen)
  return best,bestlen

def dac(target):
  best = None
  bestlen = 0
  while best == None:
    bestlen += 1
    best,bestlen = dac_search(target,1,2,3,0,0,best,bestlen)
  return best,bestlen

for bits,primes,batchsize,batchbound in data:
  fn = 'primes%d.c'%bits
  with open(fn+'.tmp','w') as f:
    f.write('// DO NOT EDIT! generated by ./autogen\n\n')
    f.write('#include "primes.h"\n')
    f.write('\n')
    keys = 1
    for s,b in zip(batchsize,batchbound):
      keys *= batchkeys(s,b)
    f.write('// number of keys: %d\n' % keys)
    f.write('// approximately 2^%f\n' % math.log(keys,2))
    f.write('\n')
   # XXX: As a matter of reproducability, we do not generate arbitrary timing
   # data and put it in a C file:
   #f.write('// average costs (calculated):\n')
   #x = distmults.average(primes,batchsize,batchbound)
   #f.write(costs.strstats(x,'// ','%.6f',primes,batchsize).strip()+'\n')
   #f.write('\n')

   #trials = 4096
   #f.write('// average costs (%d simulated trials):\n' % trials)
   #y = {}
   #for trial in range(trials):
   #  x = sim.trial(primes,batchsize,batchbound)
   #  for cost in x:
   #    if cost not in y: y[cost] = 0
   #    y[cost] += x[cost]
   #for cost in y: y[cost] *= 1.0/trials
   #f.write(costs.strstats(y,'// ','%.6f',primes,batchsize).strip()+'\n')
   #f.write('\n')

    f.write('const long long primes[primes_num] = {\n')
    f.write(' ')
    for l in primes:
      assert l < 2**63
      f.write(' %d,' % l)
    f.write('\n')
    f.write('};\n')
    f.write('\n')
    primesdac = [dac(l) for l in primes]
    f.write('const long long primes_dac[primes_num] = {\n')
    f.write(' ')
    for D in primesdac:
      assert D[0] < 2**63
      f.write(' %d,' % D[0])
    f.write('\n')
    f.write('};\n')
    f.write('\n')
    f.write('const long long primes_daclen[primes_num] = {\n')
    f.write(' ')
    for D in primesdac:
      assert D[1] < 2**63
      f.write(' %d,' % D[1])
    f.write('\n')
    f.write('};\n')
    f.write('\n')
    f.write('const long long primes_batchsize[primes_batches] = {\n')
    f.write(' ')
    for s in batchsize:
      f.write(' %d,' % s)
    f.write('\n')
    f.write('};\n')
    f.write('\n')
    f.write('const long long primes_batchstart[primes_batches] = {\n')
    f.write(' ')
    pos = 0
    for s in batchsize:
      f.write(' %d,' % pos)
      pos += s
    f.write('\n')
    f.write('};\n')
    f.write('\n')
    f.write('const long long primes_batchstop[primes_batches] = {\n')
    f.write(' ')
    pos = 0
    for s in batchsize:
      pos += s
      f.write(' %d,' % pos)
    f.write('\n')
    f.write('};\n')
    f.write('\n')
    f.write('const long long primes_batchmaxdaclen[primes_batches] = {\n')
    f.write(' ')
    pos = 0
    for s in batchsize:
      f.write(' %d,' % max(D[1] for D in primesdac[pos:pos+s]))
      pos += s
    f.write('\n')
    f.write('};\n')
    f.write('\n')
    f.write('const long long primes_batchbound[primes_batches] = {\n')
    f.write(' ')
    for s in batchbound:
      f.write(' %d,' % s)
    f.write('\n')
    f.write('};\n')
  maybeupdate(fn)

fn = 'primes.h'
with open(fn+'.tmp','w') as f:
  f.write('// DO NOT EDIT! generated by ./autogen\n\n')
  f.write('#ifndef primes_h\n')
  f.write('#define primes_h\n')
  f.write('\n')
  f.write('#include "primes_namespace.h"\n')
  f.write('\n')

  hashif = '#if'
  for bits,primes,batchsize,batchbound in data:
    f.write('%s BITS == %d\n' % (hashif,bits))
    f.write('#define primes_num %d\n' % len(primes))
    f.write('#define primes_batches %d\n' % len(batchsize))
    m = max(b+s for b,s in zip(batchbound,batchsize))
    f.write('#define primes_maxbatchboundplussize %d\n' % m)
    hashif = '#elif'

  f.write('#else\n')
  orbits = ' or '.join('%d'%bits for bits,primes,batchsize,batchbound in data)
  f.write('#error BITS must be %s\n' % orbits)
  f.write('#endif\n')
  f.write('\n')
  f.write('extern const long long primes[primes_num];\n')
  f.write('extern const long long primes_dac[primes_num];\n')
  f.write('extern const long long primes_daclen[primes_num];\n')
  f.write('extern const long long primes_batchsize[primes_batches];\n')
  f.write('extern const long long primes_batchstart[primes_batches];\n')
  f.write('extern const long long primes_batchstop[primes_batches];\n')
  f.write('extern const long long primes_batchbound[primes_batches];\n')
  f.write('extern const long long primes_batchmaxdaclen[primes_batches];\n')
  f.write('\n')
  f.write('#endif\n')
maybeupdate(fn)

def writeconst(f,n,limbs):
  assert n >= 0

  nquad = []
  while n:
    nquad += [n%(1<<64)]
    n >>= 64

  while len(nquad) < limbs:
    nquad += [0]
  assert len(nquad) == limbs

  while len(nquad) > 0:
    nquad4,nquad = nquad[:4],nquad[4:]
    f.write('    .quad %s\n' % ', '.join('%d'%x if x<10 else '0x%016x'%x for x in nquad4))

for bits,primes,batchsize,batchbound in data:
  p = 4
  for l in primes: p *= l
  p -= 1
  pbits = 0
  while (1<<pbits)<=p:
    pbits += 1
  pbytes = (pbits+7)//8
  plimbs = (pbytes+7)//8
  pmontbits = 64*plimbs

  sqrt16p = 1
  while True:
    if sqrt16p**2 <= 16*p and (sqrt16p+1)**2 > 16*p:
      break
    sqrt16p = (sqrt16p+(16*p)//sqrt16p)//2

  inv = 2**64-pow(p,2**62-1,2**64)

  invchain = chain.chain2(p-2)
  invchaincost = chain.cost2(invchain)

  fn = 'fp_inv%s.c'%bits
  with open(fn+'.tmp','w') as f:
    f.write('// DO NOT EDIT! generated by ./autogen\n\n')
    f.write('#include "fp.h"\n')
    f.write('\n')
    f.write('// %s mults, %s squarings\n' % invchaincost)
    f.write('void fp_inv(fp *x)\n')
    f.write('{\n')
    f.write(chain.code(invchain))
    f.write('}\n')
  maybeupdate(fn)

  sqrtchain = chain.chain2((p+1)//4)
  sqrtchaincost = chain.cost2(sqrtchain)

  fn = 'fp_sqrt%s.c'%bits
  with open(fn+'.tmp','w') as f:
    f.write('// DO NOT EDIT! generated by ./autogen\n\n')
    f.write('#include "fp.h"\n')
    f.write('\n')
    f.write('// %s mults, %s squarings\n' %
      (sqrtchaincost[0],sqrtchaincost[1]+1))
    f.write('long long fp_sqrt(fp *x)\n')
    f.write('{\n')
    f.write('  fp origx = *x;\n')
    f.write(chain.code(sqrtchain))
    f.write('  fp check; fp_sq2(&check,x);\n')
    f.write('  return fp_isequal(&check,&origx);\n')
    f.write('}\n')
  maybeupdate(fn)

  fn = 'uintbig%s.S'%bits
  with open(fn+'.tmp','w') as f:
    f.write('/* DO NOT EDIT! generated by ./autogen */\n')
    f.write('\n')
    f.write('.intel_syntax noprefix\n')
    f.write('\n')
    f.write('//#include "uintbig_namespace.h"\n')
    f.write('\n')
    f.write('.section .rodata\n')
    f.write('\n')

    symbol = 'highctidh_%s_uintbig_1' % bits
    f.write('.global %s\n' % symbol)
    f.write('%s:\n' % symbol)
    writeconst(f,1,plimbs)
    f.write('    .size %s, %d\n' % (symbol, pbytes))
    f.write('    .type %s, @object\n' % symbol)
    f.write('\n')

    symbol = 'highctidh_%s_uintbig_p' % bits
    f.write('.global %s\n' % symbol)
    f.write('%s:\n' % symbol)
    writeconst(f,p,plimbs)
    f.write('    .size %s, %d\n' % (symbol, pbytes))
    f.write('    .type %s, @object\n' % symbol)
    f.write('\n')

    symbol = 'highctidh_%s_uintbig_four_sqrt_p' % bits
    f.write('.global %s\n' % symbol)
    f.write('%s:\n' % symbol)
    writeconst(f,sqrt16p,plimbs)
    f.write('    .size %s, %d\n' % (symbol, pbytes))
    f.write('    .type %s, @object\n' % symbol)
    f.write('\n')

    f.write('.section .text\n')
    f.write('\n')
    symbol = 'highctidh_%s_uintbig_set' % bits
    f.write('.global %s\n' % symbol)
    f.write('%s:\n' % symbol)
    f.write('    cld\n')
    f.write('    mov rax, rsi\n')
    f.write('    stosq\n')
    f.write('    xor rax, rax\n')
    f.write('    mov rcx, %d\n' % (plimbs-1))
    f.write('    rep stosq\n')
    f.write('    ret\n')
    f.write('\n')
    f.write('\n')
    symbol = 'highctidh_%s_uintbig_bit' % bits
    f.write('.global %s\n' % symbol)
    f.write('%s:\n' % symbol)
    f.write('    mov rcx, rsi\n')
    f.write('    and rcx, 0x3f\n')
    f.write('    shr rsi, 6\n')
    f.write('    mov rax, [rdi + 8*rsi]\n')
    f.write('    shr rax, cl\n')
    f.write('    and rax, 1\n')
    f.write('    ret\n')
    f.write('\n')
    f.write('\n')
    symbol = 'highctidh_%s_uintbig_add3' % bits
    f.write('.global %s\n' % symbol)
    f.write('%s:\n' % symbol)
    f.write('    mov rax, [rsi +  0]\n')
    f.write('    add rax, [rdx +  0]\n')
    f.write('    mov [rdi +  0], rax\n')
    f.write('    .set k, 1\n')
    f.write('    .rept %d\n' % (plimbs-1))
    f.write('        mov rax, [rsi + 8*k]\n')
    f.write('        adc rax, [rdx + 8*k]\n')
    f.write('        mov [rdi + 8*k], rax\n')
    f.write('        .set k, k+1\n')
    f.write('    .endr\n')
    f.write('    setc al\n')
    f.write('    movzx rax, al\n')
    f.write('    ret\n')
    f.write('\n')
    symbol = 'highctidh_%s_uintbig_sub3' % bits
    f.write('.global %s\n' % symbol)
    f.write('%s:\n' % symbol)
    f.write('    mov rax, [rsi +  0]\n')
    f.write('    sub rax, [rdx +  0]\n')
    f.write('    mov [rdi +  0], rax\n')
    f.write('    .set k, 1\n')
    f.write('    .rept %d\n' % (plimbs-1))
    f.write('        mov rax, [rsi + 8*k]\n')
    f.write('        sbb rax, [rdx + 8*k]\n')
    f.write('        mov [rdi + 8*k], rax\n')
    f.write('        .set k, k+1\n')
    f.write('    .endr\n')
    f.write('    setc al\n')
    f.write('    movzx rax, al\n')
    f.write('    ret\n')
    f.write('\n')
    f.write('\n')
    symbol = 'highctidh_%s_uintbig_mul3_64' % bits
    f.write('.global %s\n' % symbol)
    f.write('%s:\n' % symbol)
    f.write('\n')
    f.write('    mulx r10, rax, [rsi +  0]\n')
    f.write('    mov [rdi +  0], rax\n')
    f.write('\n')
    for i in range(1,plimbs):
      if i&1:
        f.write('    mulx r11, rax, [rsi + %d]\n' % (8*i))
        if i == 1:
          f.write('    add  rax, r10\n')
        else:
          f.write('    adcx rax, r10\n')
        f.write('    mov [rdi + %d], rax\n' % (8*i))
      else:
        f.write('    mulx r10, rax, [rsi + %d]\n' % (8*i))
        f.write('    adcx rax, r11\n')
        f.write('    mov [rdi + %d], rax\n' % (8*i))
      f.write('\n')
    f.write('    ret\n')

  maybeupdate(fn)

  fn = 'fp%s.S'%bits
  prefix = 'highctidh_%s_' % bits
  with open(fn+'.tmp','w') as f:
    f.write('/* DO NOT EDIT! generated by ./autogen */\n')
    f.write('\n')
    f.write('.intel_syntax noprefix\n')
    f.write('\n')
    f.write('//#include "uintbig_namespace.h"\n')
    f.write('//#include "fp_namespace.h"\n')
    f.write('\n')
    f.write('.section .rodata\n')
    f.write('\n')
    f.write('.set pbits,%d\n' % pbits)
    f.write('.set pbytes,%d\n' % pbytes)
    f.write('.set plimbs,%d\n' % plimbs)

    f.write('.uintbig_p_local:\n')
    writeconst(f,p,plimbs)
    f.write('\n')

    f.write('.%sinv_min_p_mod_r: /* -p^-1 mod 2^64 */\n' % prefix)
    writeconst(f,inv,1)
    f.write('\n')

    f.write('.global %sfp_0\n' % prefix)
    f.write('%sfp_0:\n' % prefix)
    f.write('    .zero %d\n' % pbytes)
    f.write('    .size %sfp_0, %d\n' % (prefix, pbytes))
    f.write('    .type %sfp_0, @object\n' % prefix)
    f.write('\n')

    f.write('.global %sfp_1\n' % prefix)
    f.write('%sfp_1: /* 2^%d mod p */\n' % (prefix, pmontbits))
    writeconst(f,(1<<pmontbits)%p,plimbs)
    f.write('    .size %sfp_1, %d\n' % (prefix, pbytes))
    f.write('    .type %sfp_1, @object\n' % prefix)
    f.write('\n')

    f.write('.global %sfp_2\n' % prefix)
    f.write('%sfp_2: /* 2^%d mod p */\n' % (prefix, pmontbits+1))
    writeconst(f,(1<<(pmontbits+1))%p,plimbs)
    f.write('    .size %sfp_2, %d\n' % (prefix, pbytes))
    f.write('    .type %sfp_2, @object\n' % prefix)
    f.write('\n')

    f.write('.%sr_squared_mod_p: /* (2^%d)^2 mod p */\n' % (prefix, pmontbits))
    writeconst(f,(1<<(2*pmontbits))%p,plimbs)
    f.write('\n')

    # f.write('.global p_minus_2\n')
    # f.write('p_minus_2:\n')
    # writeconst(f,p-2,plimbs)
    # f.write('\n')

    # f.write('.global p_minus_1_halves\n')
    # f.write('p_minus_1_halves:\n')
    # writeconst(f,(p-1)//2,plimbs)
    # f.write('\n')

    f.write('.section .data\n')
    f.write('.global %sfp_mulsq_count\n' % prefix)
    f.write('%sfp_mulsq_count:\n' % prefix)
    f.write('    .quad 0\n')
    f.write('.global %sfp_sq_count\n' % prefix)
    f.write('%sfp_sq_count:\n' % prefix)
    f.write('    .quad 0\n')
    f.write('.global %sfp_addsub_count\n' % prefix)
    f.write('%sfp_addsub_count:\n' % prefix)
    f.write('    .quad 0\n')
    f.write('\n')
    f.write('.section .text\n')
    f.write('.p2align 4,,15\n')
    f.write('\n')
    f.write('.global %sfp_copy\n' % prefix)
    f.write('%sfp_copy:\n' % prefix)
    f.write('    cld\n')
    f.write('    mov rcx, plimbs\n')
    f.write('    rep movsq\n')
    f.write('    ret\n')
    f.write('\n')
    f.write('.global %sfp_cmov\n' % prefix)
    f.write('%sfp_cmov:\n' % prefix)
    f.write('    movzx rax, dl\n')
    f.write('    neg rax\n')
    f.write('    .set k, 0\n')
    f.write('    .rept plimbs\n')
    f.write('        mov rcx, [rdi + 8*k]\n')
    f.write('        mov rdx, [rsi + 8*k]\n')
    f.write('\n')
    f.write('        xor rdx, rcx\n')
    f.write('        and rdx, rax\n')
    f.write('        xor rcx, rdx\n')
    f.write('\n')
    f.write('        mov [rdi + 8*k], rcx\n')
    f.write('\n')
    f.write('        .set k, k+1\n')
    f.write('    .endr\n')
    f.write('    ret\n')
    f.write('\n')
    f.write('.global %sfp_cswap\n' % prefix)
    f.write('%sfp_cswap:\n' % prefix)
    f.write('    movzx rax, dl\n')
    f.write('    neg rax\n')
    f.write('    .set k, 0\n')
    f.write('    .rept plimbs\n')
    f.write('        mov rcx, [rdi + 8*k]\n')
    f.write('        mov rdx, [rsi + 8*k]\n')
    f.write('\n')
    f.write('        mov r8, rcx\n')
    f.write('        xor r8, rdx\n')
    f.write('        and r8, rax\n')
    f.write('\n')
    f.write('        xor rcx, r8\n')
    f.write('        xor rdx, r8\n')
    f.write('\n')
    f.write('        mov [rdi + 8*k], rcx\n')
    f.write('        mov [rsi + 8*k], rdx\n')
    f.write('\n')
    f.write('        .set k, k+1\n')
    f.write('    .endr\n')
    f.write('    ret\n')
    f.write('\n')
    f.write('.%sreduce_once:\n' % prefix)
    f.write('    push rbp\n')
    if plimbs > 8:
      f.write('    sub rsp, %d\n' % (8*(plimbs-8)))
    f.write('    mov rbp, rdi\n')
    f.write('\n')

    regs = ('rdi','rsi','rdx','rcx','r8','r9','r10','r11')
    for i in range(plimbs):
      regi = regs[i%len(regs)]+', '
      if len(regi) < 5: regi += ' '
      f.write('    mov %s[rbp + %d]\n' % (regi,i*8))
      if i == 0:
        f.write('    sub %s[rip + .uintbig_p_local + %d]\n' % (regi,i*8))
      else:
        f.write('    sbb %s[rip + .uintbig_p_local + %d]\n' % (regi,i*8))
      if i < plimbs-8:
        f.write('    mov qword ptr [rsp + %d], %s\n' % (8*i,regs[i%len(regs)]))

    f.write('\n')
    f.write('    setnc al\n')
    f.write('    movzx rax, al\n')
    f.write('    neg rax\n')
    f.write('\n')
    f.write('.macro cswap2, r, m\n')
    f.write('    xor \\r, \\m\n')
    f.write('    and \\r, rax\n')
    f.write('    xor \\m, \\r\n')
    f.write('.endm\n')
    f.write('\n')

    for i in range(plimbs-8,plimbs):
      regi = regs[i%len(regs)]
      f.write('    cswap2 %s, [rbp + %d]\n' % (regi,8*i))

    for i in range(plimbs-8):
      regi = regs[i%len(regs)]
      f.write('    mov %s, [rsp + %d]\n' % (regs[i%len(regs)],8*i))
      f.write('    cswap2 %s, [rbp + %d]\n' % (regi,8*i))
    f.write('\n')

    if plimbs > 8:
      f.write('    add rsp, %d\n' % (8*(plimbs-8)))
    f.write('    pop rbp\n')
    f.write('    ret\n')
    f.write('\n')
    f.write('.global %sfp_add2\n' % prefix)
    f.write('%sfp_add2:\n' % prefix)
    f.write('    mov rdx, rdi\n')
    f.write('.global %sfp_add3\n' % prefix)
    f.write('%sfp_add3:\n' % prefix)
    f.write('    mov rax, [rip + %sfp_addsub_count@GOTPCREL]\n' % prefix)
    f.write('    add qword ptr [rax], 1\n')
    f.write('    push rdi\n')
    f.write('    call %suintbig_add3\n' % prefix)
    f.write('    pop rdi\n')
    f.write('    jmp .%sreduce_once\n' % prefix)
    f.write('\n')
    f.write('.global %sfp_sub2\n' % prefix)
    f.write('%sfp_sub2:\n' % prefix)
    f.write('  mov rdx, rdi\n')
    f.write('  xchg rsi, rdx\n')
    f.write('.global %sfp_sub3\n' % prefix)
    f.write('%sfp_sub3:\n' % prefix)
    f.write('    mov rax, [rip + %sfp_addsub_count@GOTPCREL]\n' % prefix)
    f.write('    add qword ptr [rax], 1\n')
    f.write('    push rdi\n')
    f.write('    call %suintbig_sub3\n' % prefix)
    f.write('    pop rdi\n')
    f.write('    neg rax\n')
    f.write('\n')
    f.write('    sub rsp, pbytes\n')
    f.write('\n')
    f.write('    mov rcx, [rip + .uintbig_p_local +  0]\n')
    f.write('    and rcx, rax\n')
    f.write('    mov [rsp + 0],rcx\n')
    f.write('    .set k, 1\n')
    f.write('    .rept plimbs-1\n')
    f.write('        mov rcx, [rip + .uintbig_p_local + 8*k]\n')
    f.write('        and rcx, rax\n')
    f.write('        mov [rsp + 8*k], rcx\n')
    f.write('        .set k, k+1\n')
    f.write('    .endr\n')
    f.write('\n')
    f.write('    mov rcx, [rsp +  0]\n')
    f.write('    add rcx, [rdi +  0]\n')
    f.write('    mov [rdi +  0], rcx\n')
    f.write('    .set k, 1\n')
    f.write('    .rept plimbs-1\n')
    f.write('        mov rcx, [rsp + 8*k]\n')
    f.write('        adc rcx, [rdi + 8*k]\n')
    f.write('        mov [rdi + 8*k], rcx\n')
    f.write('        .set k, k+1\n')
    f.write('    .endr\n')
    f.write('\n')
    f.write('    add rsp, pbytes\n')

    f.write('    ret\n')
    f.write('\n')
    f.write('\n')
    f.write('/* Montgomery arithmetic */\n')
    f.write('\n')
    f.write('.global %sfp_mul2\n' % prefix)
    f.write('%sfp_mul2:\n' % prefix)
    f.write('  mov rdx, rdi\n')

    f.write('.global %sfp_mul3\n' % prefix)
    f.write('%sfp_mul3:\n' % prefix)
    f.write('    push rbp\n')
    f.write('    push rbx\n')

    if plimbs == 8:
      f.write('    push r12\n')
      f.write('    push r13\n')
      f.write('    push r14\n')
      f.write('    push r15\n')
      f.write('\n')
      f.write('    push rdi\n')
      f.write('\n')
      f.write('    mov rax, [rip + %sfp_mulsq_count@GOTPCREL]\n' % prefix)
      f.write('    add qword ptr [rax], 1\n')
      f.write('\n')
      f.write('    mov rdi, rsi\n')
      f.write('    mov rsi, rdx\n')
      f.write('\n')
      f.write('    xor r8,  r8\n')
      f.write('    xor r9,  r9\n')
      f.write('    xor r10, r10\n')
      f.write('    xor r11, r11\n')
      f.write('    xor r12, r12\n')
      f.write('    xor r13, r13\n')
      f.write('    xor r14, r14\n')
      f.write('    xor r15, r15\n')
      f.write('    xor rbp, rbp\n')
      f.write('\n')
      f.write('    /* flags are already cleared */\n')
      f.write('\n')
      f.write('.macro MULSTEP, k, r0, r1, r2, r3, r4, r5, r6, r7, r8\n')
      f.write('\n')
      f.write('    mov rdx, [rsi +  0]\n')
      f.write('    mulx rcx, rdx, [rdi + 8*\\k]\n')
      f.write('    add rdx, \\r0\n')
      f.write('    mulx rcx, rdx, [rip + .%sinv_min_p_mod_r]\n' % prefix)
      f.write('\n')
      f.write('    xor rax, rax /* clear flags */\n')
      f.write('\n')
      f.write('    mulx rbx, rax, [rip + .uintbig_p_local +  0]\n')
      f.write('    adox \\r0, rax\n')
      f.write('\n')
      f.write('    mulx rcx, rax, [rip + .uintbig_p_local +  8]\n')
      f.write('    adcx \\r1, rbx\n')
      f.write('    adox \\r1, rax\n')
      f.write('\n')
      f.write('    mulx rbx, rax, [rip + .uintbig_p_local + 16]\n')
      f.write('    adcx \\r2, rcx\n')
      f.write('    adox \\r2, rax\n')
      f.write('\n')
      f.write('    mulx rcx, rax, [rip + .uintbig_p_local + 24]\n')
      f.write('    adcx \\r3, rbx\n')
      f.write('    adox \\r3, rax\n')
      f.write('\n')
      f.write('    mulx rbx, rax, [rip + .uintbig_p_local + 32]\n')
      f.write('    adcx \\r4, rcx\n')
      f.write('    adox \\r4, rax\n')
      f.write('\n')
      f.write('    mulx rcx, rax, [rip + .uintbig_p_local + 40]\n')
      f.write('    adcx \\r5, rbx\n')
      f.write('    adox \\r5, rax\n')
      f.write('\n')
      f.write('    mulx rbx, rax, [rip + .uintbig_p_local + 48]\n')
      f.write('    adcx \\r6, rcx\n')
      f.write('    adox \\r6, rax\n')
      f.write('\n')
      f.write('    mulx rcx, rax, [rip + .uintbig_p_local + 56]\n')
      f.write('    adcx \\r7, rbx\n')
      f.write('    adox \\r7, rax\n')
      f.write('\n')
      f.write('    mov rax, 0\n')
      f.write('    adcx \\r8, rcx\n')
      f.write('    adox \\r8, rax\n')
      f.write('\n')
      f.write('\n')
      f.write('    mov rdx, [rdi + 8*\\k]\n')
      f.write('\n')
      f.write('    xor rax, rax /* clear flags */\n')
      f.write('\n')
      f.write('    mulx rbx, rax, [rsi +  0]\n')
      f.write('    adox \\r0, rax\n')
      f.write('\n')
      f.write('    mulx rcx, rax, [rsi +  8]\n')
      f.write('    adcx \\r1, rbx\n')
      f.write('    adox \\r1, rax\n')
      f.write('\n')
      f.write('    mulx rbx, rax, [rsi + 16]\n')
      f.write('    adcx \\r2, rcx\n')
      f.write('    adox \\r2, rax\n')
      f.write('\n')
      f.write('    mulx rcx, rax, [rsi + 24]\n')
      f.write('    adcx \\r3, rbx\n')
      f.write('    adox \\r3, rax\n')
      f.write('\n')
      f.write('    mulx rbx, rax, [rsi + 32]\n')
      f.write('    adcx \\r4, rcx\n')
      f.write('    adox \\r4, rax\n')
      f.write('\n')
      f.write('    mulx rcx, rax, [rsi + 40]\n')
      f.write('    adcx \\r5, rbx\n')
      f.write('    adox \\r5, rax\n')
      f.write('\n')
      f.write('    mulx rbx, rax, [rsi + 48]\n')
      f.write('    adcx \\r6, rcx\n')
      f.write('    adox \\r6, rax\n')
      f.write('\n')
      f.write('    mulx rcx, rax, [rsi + 56]\n')
      f.write('    adcx \\r7, rbx\n')
      f.write('    adox \\r7, rax\n')
      f.write('\n')
      f.write('    mov rax, 0\n')
      f.write('    adcx \\r8, rcx\n')
      f.write('    adox \\r8, rax\n')
      f.write('\n')
      f.write('.endm\n')
      f.write('\n')
      f.write('    MULSTEP 0, r8,  r9,  r10, r11, r12, r13, r14, r15, rbp\n')
      f.write('    MULSTEP 1, r9,  r10, r11, r12, r13, r14, r15, rbp, r8\n')
      f.write('    MULSTEP 2, r10, r11, r12, r13, r14, r15, rbp, r8,  r9\n')
      f.write('    MULSTEP 3, r11, r12, r13, r14, r15, rbp, r8,  r9,  r10\n')
      f.write('    MULSTEP 4, r12, r13, r14, r15, rbp, r8,  r9,  r10, r11\n')
      f.write('    MULSTEP 5, r13, r14, r15, rbp, r8,  r9,  r10, r11, r12\n')
      f.write('    MULSTEP 6, r14, r15, rbp, r8,  r9,  r10, r11, r12, r13\n')
      f.write('    MULSTEP 7, r15, rbp, r8,  r9,  r10, r11, r12, r13, r14\n')
      f.write('\n')
      f.write('    pop rdi\n')
      f.write('\n')
      f.write('    mov [rdi +  0], rbp\n')
      f.write('    mov [rdi +  8], r8\n')
      f.write('    mov [rdi + 16], r9\n')
      f.write('    mov [rdi + 24], r10\n')
      f.write('    mov [rdi + 32], r11\n')
      f.write('    mov [rdi + 40], r12\n')
      f.write('    mov [rdi + 48], r13\n')
      f.write('    mov [rdi + 56], r14\n')
      f.write('\n')
      f.write('    pop r15\n')
      f.write('    pop r14\n')
      f.write('    pop r13\n')
      f.write('    pop r12\n')
    else:
      f.write('\n')
      f.write('  mov rax, [rip + %sfp_mulsq_count@GOTPCREL]\n' % prefix)
      f.write('  add qword ptr [rax], 1\n')
      f.write('\n')
      f.write('  sub rsp,%d\n' % (8*plimbs+16))
      f.write('  mov [rsp+%d],rdi\n' % (8*plimbs+8))
      f.write('  mov rdi,rsi\n')
      f.write('  mov rsi,rdx\n')
      f.write('\n')
      f.write('  /* XXX: put directly into output */\n')
      f.write('  xor rax,rax\n')
      for i in range(plimbs+1):
        f.write('  mov [rsp+%d],rax\n' % (8*i))
      f.write('\n')
      f.write('.macro MULSTEP, k, %s\n' % ', '.join('I%d' % i for i in range(plimbs+1)))
      f.write('\n')
      f.write('    mov r11,[rsp+\\I0]\n')
      f.write('    mov rdx, [rsi +  0]\n')
      f.write('    mulx rcx, rdx, [rdi + 8*\\k]\n')
      f.write('    add rdx, r11\n')
      f.write('    mulx rcx, rdx, [rip + .%sinv_min_p_mod_r]\n' % prefix)
      f.write('\n')
      f.write('    xor rax, rax /* clear flags */\n')
      f.write('\n')
      f.write('    mulx rbx, rax, [rip + .uintbig_p_local +  0]\n')
      f.write('    adox r11, rax\n')
      f.write('    mov [rsp+\\I0],r11\n')
      f.write('\n')

      for i in range(1,plimbs):
        f.write('    mov r11,[rsp+\\I%d]\n' % i)
        if i&1:
          f.write('    mulx rcx, rax, [rip + .uintbig_p_local + %d]\n' % (8*i))
          f.write('    adcx r11, rbx\n')
          f.write('    adox r11, rax\n')
        else:
          f.write('    mulx rbx, rax, [rip + .uintbig_p_local + %d]\n' % (8*i))
          f.write('    adcx r11, rcx\n')
          f.write('    adox r11, rax\n')
        f.write('    mov [rsp+\\I%d],r11\n' % i)
        f.write('\n')

      f.write('    mov r11,[rsp+\\I%d]\n' % plimbs)
      f.write('    mov rax, 0\n')
      if plimbs&1:
        f.write('    adcx r11, rbx\n')
        f.write('    adox r11, rax\n')
      else:
        f.write('    adcx r11, rcx\n')
        f.write('    adox r11, rax\n')
      f.write('    mov [rsp+\\I%d],r11\n' % plimbs)
      f.write('\n')

      f.write('    mov rdx, [rdi + 8*\\k]\n')
      f.write('\n')
      f.write('    xor rax, rax /* clear flags */\n')
      f.write('\n')
      f.write('    mov r11,[rsp+\\I0]\n')
      f.write('    mulx rbx, rax, [rsi +  0]\n')
      f.write('    adox r11, rax\n')
      f.write('    mov [rsp+\\I0],r11\n')
      f.write('\n')

      for i in range(1,plimbs):
        f.write('    mov r11,[rsp+\\I%d]\n' % i)
        if i&1:
          f.write('    mulx rcx, rax, [rsi + %d]\n' % (8*i))
          f.write('    adcx r11, rbx\n')
          f.write('    adox r11, rax\n')
        else:
          f.write('    mulx rbx, rax, [rsi + %d]\n' % (8*i))
          f.write('    adcx r11, rcx\n')
          f.write('    adox r11, rax\n')
        f.write('    mov [rsp+\\I%d],r11\n' % i)
        f.write('\n')

      f.write('    mov r11,[rsp+\\I%d]\n' % plimbs)
      f.write('    mov rax, 0\n')
      if plimbs&1:
        f.write('    adcx r11, rbx\n')
        f.write('    adox r11, rax\n')
      else:
        f.write('    adcx r11, rcx\n')
        f.write('    adox r11, rax\n')
      f.write('    mov [rsp+\\I%d],r11\n' % plimbs)
      f.write('\n')

      f.write('.endm\n')
      f.write('\n')

      for i in range(plimbs):
        indices = ['%d' % (8*((j+i+1)%(plimbs+1))) for j in range(plimbs+1)]
        indices = ', '.join(indices)
        f.write('    MULSTEP %d, %s\n' % (i,indices))
      f.write('\n')
      f.write('    mov rdi,[rsp+%d]\n' % (8*plimbs+8))
      f.write('\n')

      for i in range(plimbs):
        f.write('    mov r11,[rsp+%d]\n' % (8*i))
        f.write('    mov [rdi+%d],r11\n' % (8*i))
      f.write('\n')
      f.write('    add rsp,%d\n' % (8*plimbs+16))
      f.write('\n')

    f.write('    pop rbx\n')
    f.write('    pop rbp\n')
    f.write('    jmp .%sreduce_once\n' % prefix)
    f.write('\n')

    f.write('.global %sfp_sq1\n' % prefix)
    f.write('%sfp_sq1:\n' % prefix)
    f.write('    mov rsi, rdi\n')
    f.write('.global %sfp_sq2\n' % prefix)
    f.write('%sfp_sq2:\n' % prefix)
    f.write('    /* TODO implement optimized Montgomery squaring */\n')
    f.write('    mov rdx, rsi\n')
    f.write('    mov rax, [rip + %sfp_sq_count@GOTPCREL]\n' % prefix)
    f.write('    add qword ptr [rax], 1\n')
    f.write('    jmp %sfp_mul3\n' % prefix)

  maybeupdate(fn)
